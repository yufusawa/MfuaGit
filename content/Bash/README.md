# Bash скрипты для начинающих

# История появления и развития Bash

## Предыстория (1970-е годы)

### Unix и первые shell

**1971年** - Кен Томпсон создал первый Unix shell (Thompson shell) в Bell Labs:
- Очень простой
- Базовые возможности: запуск программ, перенаправление ввода/вывода
- Не поддерживал скрипты

**1977年** - Стивен Борн создал Bourne shell (sh):
- Стал стандартной оболочкой Unix Version 7
- Поддержка скриптинга
- Переменные, управляющие структуры, функции

## Появление Bash (1989年)

### Брайан Фокс и Free Software Foundation

**Контекст:**
- Ричард Столлман начал проект GNU в 1984 году
- Нужна была свободная оболочка, совместимая с Bourne shell
- Существовавшие оболочки были проприетарными

**1989年** - Брайан Фокс создает Bash (Bourne Again SHell):
- Игра слов: "Bourne again" (возрожденный Bourne) и "born again" (рожденный заново)
- Цель: полная замена Bourne shell с дополнительными возможностями
- Версия 1.00 вышла 8 июня 1989 года

## Ключевые вехи развития

### Bash 1.x (1989-1994)

**Основные нововведения:**
- Совместимость с Bourne shell
- История команд (command history)
- Автодополнение (tab completion)
- Редактирование командной строки
- Алиасы (псевдонимы команд)

### Bash 2.x (1996-2002)

**Версия 2.0 (1996):**
- Поддержка массивов
- Улучшенное расширение переменных
- Более развитые управляющие структуры

**Версия 2.05 (2001):**
- Поддержка локалей
- Улучшенная обработка сигналов

### Bash 3.x (2004-2009)

**Версия 3.0 (2004):**
- Регулярные выражения в условных конструкциях
- Улучшенная поддержка Unicode
- Новые операторы сравнения

**Версия 3.2 (2006):**
- Значительные улучшения безопасности
- Исправления уязвимостей

### Bash 4.x (2009-2016)

**Версия 4.0 (2009):**
- Ассоциативные массивы
- Улучшенная автодополнение
- Поддержка перенаправления для групп команд

**Версия 4.1 (2010):**
- Улучшения для скриптинга
- Новые встроенные команды

### Bash 5.x (2019-настоящее время)

**Версия 5.0 (2019):**
- Динамические переменные
- Улучшения производительности
- Новые возможности для разработчиков

## Ключевые личности

### Брайан Фокс (Brian Fox)
- Главный разработчик Bash (1988-1992)
- Создал Bash в возрасте 27 лет
- Работал в Free Software Foundation

### Чет Рэми (Chet Ramey)
- Второй и текущий maintainer Bash (с 1990 года)
- Работает в Case Western Reserve University
- Поддерживает и развивает Bash более 30 лет

## Технические инновации Bash

### 1. Совместимость
```bash
# Работает как в Bourne shell, так и в Bash
echo "Hello World"
```

### 2. Интерактивные возможности
- История команд с поиском (Ctrl+R)
- Автодополнение табуляцией
- Редактирование командной строки

### 3. Расширения синтаксиса
```bash
# Арифметические операции
result=$((a + b))

# Подстановка команд
current_dir=$(pwd)

# Расширенные тесты
if [[ $string =~ pattern ]]; then
```

## Распространение и стандартизация

### Статус по умолчанию
- Стандартная оболочка в большинстве Linux-дистрибутивов
- Доступна в macOS (хотя zsh теперь по умолчанию)
- Портируема на Windows через WSL, Cygwin, Git Bash

### POSIX-совместимость
Bash в основном совместим со стандартом POSIX, но имеет много расширений.

## Знаменитые инциденты

### Shellshock (2014)
- Серьезная уязвимость в Bash
- Обнаружена 24 сентября 2014 года
- Затронула миллионы систем
- Показала важность Bash в интернет-инфраструктуре

```bash
# Пример уязвимости Shellshock
env x='() { :;}; echo vulnerable' bash -c "echo test"
```

## Современное состояние

### Конкуренция
- **zsh**: популярна благодаря Oh My Zsh, теперь по умолчанию в macOS
- **fish**: дружелюбная к пользователю оболочка
- **PowerShell**: кроссплатформенная оболочка от Microsoft

### Почему Bash остается популярным?
```bash
# Универсальность
# Работает везде
# Огромная база существующих скриптов
# Простота для автоматизации
```

## Влияние на IT-индустрию

### Девопс и автоматизация
Bash стал фундаментом для:
- Скриптов развертывания
- CI/CD пайплайнов
- Управления контейнерами
- Автоматизации системного администрирования

### Образование
- Первый язык сценариев для многих администраторов
- Основа для понимания Unix-систем
- Обязательный навык в IT-профессиях

## Будущее Bash

Несмотря на появление новых оболочек, Bash продолжает развиваться благодаря:
- Обратной совместимости
- Огромной установленной базе
- Активной разработке
- Простоте для базовых задач

Bash прошел путь от замены проприетарных оболочек до становления стандартом де-факто в мире Linux и основным инструментом автоматизации в IT-индустрии. Его история - это пример успеха философии открытого программного обеспечения.

# Создание простого скрипта на Bash

Вот как создать простой Bash-скрипт:

## 1. Создание файла скрипта

Откройте терминал и создайте новый файл с расширением `.sh`:

```bash
nano myscript.sh
```

## 2. Базовый скрипт

Добавьте в файл следующий код:

```bash
#!/bin/bash

# Это комментарий - простой Bash-скрипт

echo "Привет, мир!"
echo "Сегодня: $(date)"
echo "Текущий пользователь: $USER"
echo "Мы в директории: $(pwd)"
```

## 3. Разрешение на выполнение

Сделайте файл исполняемым:

```bash
chmod +x myscript.sh
```

## 4. Запуск скрипта

Выполните скрипт одним из способов:

```bash
./myscript.sh
```

или

```bash
bash myscript.sh
```

## Примеры простых скриптов

### 1. Скрипт-приветствие

```bash
#!/bin/bash

echo "Как вас зовут?"
read name
echo "Привет, $name! Добро пожаловать в Bash-скрипты!"
```

### 2. Проверка существования файла

```bash
#!/bin/bash

echo "Введите имя файла:"
read filename

if [ -f "$filename" ]; then
    echo "Файл $filename существует!"
else
    echo "Файл $filename не найден."
fi
```

### 3. Простой калькулятор

```bash
#!/bin/bash

echo "Введите первое число:"
read num1
echo "Введите второе число:"
read num2

echo "Сумма: $(($num1 + $num2))"
echo "Разность: $(($num1 - $num2))"
echo "Произведение: $(($num1 * $num2))"
echo "Частное: $(($num1 / $num2))"
```

## Советы по написанию Bash-скриптов

1. Всегда начинайте с `#!/bin/bash` (shebang)
2. Используйте комментарии (`#`) для пояснения кода
3. Проверяйте существование файлов/директорий перед работой с ними
4. Используйте кавычки для переменных ("$var")
5. Для арифметических операций используйте `$(())`
6. Проверяйте код выхода команд с помощью `$?`

# Полное руководство по Bash-программированию

## Что такое Bash?

**Bash** (Bourne Again SHell) - это командная оболочка Unix и язык сценариев для автоматизации задач.

## Основы синтаксиса

### 1. Создание и запуск скриптов

```bash
#!/bin/bash
# Это комментарий
echo "Привет, мир!"
```

**Запуск:**
```bash
chmod +x script.sh
./script.sh
```

### 2. Переменные

```bash
#!/bin/bash
name="Алексей"
age=25
echo "Меня зовут $name, мне $age лет"

# Чтение ввода
echo "Введите ваше имя:"
read user_name
echo "Привет, $user_name!"
```

### 3. Арифметические операции

```bash
#!/bin/bash
a=10
b=3

# Сложение
sum=$((a + b))
echo "Сумма: $sum"

# Другие операции
echo "Разность: $((a - b))"
echo "Умножение: $((a * b))"
echo "Деление: $((a / b))"
echo "Остаток: $((a % b))"
```

## Условные операторы

### if-else

```bash
#!/bin/bash
echo "Введите число:"
read number

if [ $number -gt 10 ]; then
    echo "Число больше 10"
elif [ $number -eq 10 ]; then
    echo "Число равно 10"
else
    echo "Число меньше 10"
fi
```

### Сравнения:

**Числа:**
- `-eq` - равно
- `-ne` - не равно
- `-gt` - больше
- `-lt` - меньше
- `-ge` - больше или равно
- `-le` - меньше или равно

**Строки:**
- `=` - равно
- `!=` - не равно
- `-z` - пустая строка

**Файлы:**
- `-f` - существует файл
- `-d` - существует директория
- `-r` - доступен для чтения

## Циклы

### for循环

```bash
#!/bin/bash
# Простой for
for i in 1 2 3 4 5; do
    echo "Итерация: $i"
done

# For с диапазоном
for i in {1..5}; do
    echo "Число: $i"
done

# For с файлами
for file in *.txt; do
    echo "Обрабатываю файл: $file"
done
```

### while循环

```bash
#!/bin/bash
counter=1

while [ $counter -le 5 ]; do
    echo "Счетчик: $counter"
    ((counter++))
done

# Бесконечный цикл с break
while true; do
    echo "Введите 'stop' для выхода:"
    read input
    if [ "$input" = "stop" ]; then
        break
    fi
done
```

## Функции

```bash
#!/bin/bash

# Определение функции
приветствие() {
    local name=$1
    echo "Привет, $name!"
}

# Вызов функции
приветствие "Мир"
приветствие "Пользователь"

# Функция с возвращаемым значением
сложение() {
    local a=$1
    local b=$2
    return $((a + b))
}

сложение 5 3
echo "Результат: $?"
```

## Работа с файлами

```bash
#!/bin/bash

# Проверка существования файла
if [ -f "myfile.txt" ]; then
    echo "Файл существует"
else
    echo "Файл не найден"
fi

# Чтение файла построчно
while IFS= read -r line; do
    echo "Строка: $line"
done < "myfile.txt"

# Запись в файл
echo "Это первая строка" > output.txt
echo "Это вторая строка" >> output.txt
```

## Параметры командной строки

```bash
#!/bin/bash

echo "Имя скрипта: $0"
echo "Первый параметр: $1"
echo "Второй параметр: $2"
echo "Все параметры: $@"
echo "Количество параметров: $#"

# Обработка параметров
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            echo "Помощь"
            exit 0
            ;;
        -v|--verbose)
            verbose=1
            ;;
        *)
            echo "Неизвестный параметр: $1"
            ;;
    esac
    shift
done
```

## Полезные примеры

### 1. Резервное копирование

```bash
#!/bin/bash
backup_dir="/backup/$(date +%Y%m%d)"
source_dir="/home/user/documents"

mkdir -p "$backup_dir"
cp -r "$source_dir" "$backup_dir"
echo "Резервная копия создана в: $backup_dir"
```

### 2. Мониторинг системы

```bash
#!/bin/bash
# Проверка использования диска
disk_usage=$(df -h / | awk 'NR==2 {print $5}' | cut -d'%' -f1)

if [ $disk_usage -gt 80 ]; then
    echo "ВНИМАНИЕ! Диск почти заполнен: $disk_usage%"
else
    echo "Диск в порядке: $disk_usage%"
fi
```

### 3. Обработка логов

```bash
#!/bin/bash
log_file="/var/log/syslog"

# Поиск ошибок за сегодня
today=$(date +"%Y-%m-%d")
grep -i "error" "$log_file" | grep "$today" > errors_today.txt
echo "Найдено ошибок: $(wc -l < errors_today.txt)"
```

## Отладка скриптов

```bash
#!/bin/bash
# Включение отладки
set -x  # Показывает выполняемые команды
set -e  # Выход при ошибке
set -u  # Выход при использовании необъявленных переменных

# Ваш код здесь

set +x  # Выключение отладки
```

## Лучшие практики

1. **Всегда используйте `#!/bin/bash`**
2. **Проверяйте существование файлов**
3. **Используйте кавычки для переменных**
4. **Обрабатывайте ошибки**
5. **Комментируйте сложный код**
6. **Используйте функции для повторяющихся задач**

## Практическое задание

Создайте скрипт для управления пользователями:

```bash
#!/bin/bash

add_user() {
    local username=$1
    sudo useradd -m "$username"
    echo "Пользователь $username создан"
}

delete_user() {
    local username=$1
    sudo userdel -r "$username"
    echo "Пользователь $username удален"
}

list_users() {
    cut -d: -f1 /etc/passwd | head -10
}

case "$1" in
    add)
        add_user "$2"
        ;;
    delete)
        delete_user "$2"
        ;;
    list)
        list_users
        ;;
    *)
        echo "Использование: $0 {add|delete|list} [username]"
        ;;
esac
```

Это основа для начала программирования на Bash! Начните с простых скриптов и постепенно усложняйте их.

# Операторы сравнения в Bash

## Основные способы сравнения

### 1. В двойных круглых скобках `(( ))` - для ЧИСЕЛ

```bash
#!/bin/bash
a=10
b=5

if (( a > b )); then
    echo "$a больше $b"
fi

if (( a < 15 )); then
    echo "$a меньше 15"
fi

# Работают все нормальные операторы:
# >  - больше
# <  - меньше
# >= - больше или равно
# <= - меньше или равно
# == - равно
# != - не равно
```

### 2. В двойных квадратных скобках `[[ ]]` - для СТРОК

```bash
#!/bin/bash
str1="apple"
str2="banana"

if [[ "$str1" < "$str2" ]]; then
    echo "'$str1' идет перед '$str2' в лексикографическом порядке"
fi

if [[ "$str1" > "apricot" ]]; then
    echo "'$str1' идет после 'apricot'"
fi
```

## Проблемы и ограничения

### ❌ Не работает в одиночных квадратных скобках `[ ]`

```bash
#!/bin/bash
a=10
b=5

# ЭТО НЕ СРАБОТАЕТ (или сработает некорректно):
if [ $a > $b ]; then
    echo "Это может работать неправильно!"
fi

# Вместо этого используйте:
if [ $a -gt $b ]; then
    echo "Правильно: используйте -gt для чисел"
fi
```

## Полная таблица сравнений

### Для чисел (рекомендуется `(( ))` ):

```bash
#!/bin/bash
x=10
y=20

(( x < y ))  && echo "x меньше y"
(( x > y ))  || echo "x не больше y"
(( x <= 10 )) && echo "x меньше или равно 10"
(( y >= 15 )) && echo "y больше или равно 15"
(( x == 10 )) && echo "x равно 10"
(( x != y ))  && echo "x не равно y"
```

### Для строк (рекомендуется `[[ ]]` ):

```bash
#!/bin/bash
name1="Alice"
name2="Bob"

[[ "$name1" < "$name2" ]] && echo "Alice перед Bob"
[[ "$name1" > "Aaron" ]] && echo "Alice после Aaron"
[[ "$name1" == "Alice" ]] && echo "Имя Alice"
[[ "$name1" != "$name2" ]] && echo "Имена разные"
```

## Практические примеры

### Сравнение чисел:

```bash
#!/bin/bash
read -p "Введите первое число: " num1
read -p "Введите второе число: " num2

if (( num1 > num2 )); then
    echo "$num1 > $num2"
elif (( num1 < num2 )); then
    echo "$num1 < $num2"
else
    echo "$num1 = $num2"
fi
```

### Сравнение строк (сортировка):

```bash
#!/bin/bash
echo "Введите два слова:"
read word1
read word2

if [[ "$word1" < "$word2" ]]; then
    echo "По алфавиту: $word1, $word2"
else
    echo "По алфавиту: $word2, $word1"
fi
```

### Сравнение в циклах:

```bash
#!/bin/bash
# Цикл с числовым сравнением
for (( i=1; i<=5; i++ )); do
    echo "Итерация: $i"
done

# Условие с несколькими сравнениями
value=15
if (( value > 10 && value < 20 )); then
    echo "Значение между 10 и 20"
fi
```

## Важные предупреждения

### 1. Всегда используйте правильные скобки:

```bash
# ПРАВИЛЬНО:
(( a > b ))    # для чисел
[[ "$a" < "$b" ]]  # для строк

# НЕПРАВИЛЬНО:
[ a > b ]      # может создать файл!
```

### 2. Для строк всегда используйте кавычки:

```bash
str="my file.txt"

# ОПАСНО:
[[ $str < "other" ]]  # может сломаться из-за пробелов

# БЕЗОПАСНО:
[[ "$str" < "other" ]]  # правильно
```

### 3. Пример создания файла по ошибке:

```bash
#!/bin/bash
a=10
b=5

# СЛУЧАЙНО создаст файл с именем "5"!
if [ $a > $b ]; then
    echo "Эта команда создала файл '5'!"
    ls -la 5  # файл существует!
fi
```

## Резюме

**Да, можно использовать `< >` но:**

1. **Для чисел:** Используйте `(( a > b ))`
2. **Для строк:** Используйте `[[ "$a" < "$b" ]]`
3. **Никогда не используйте** `[ a > b ]` - это опасно!
4. **Всегда заключайте строки в кавычки**

Это делает код более читаемым и похожим на другие языки программирования!

**Запись без пробелов `i=1` НЕ обязательна**, но есть важные нюансы.

## Где пробелы ВАЖНЫ, а где НЕТ

### 1. Присваивание переменных - пробелы НЕ ДОПУСТИМЫ

```bash
# ✅ ПРАВИЛЬНО - без пробелов
i=1
name="Alex"
count=10

# ❌ НЕПРАВИЛЬНО - с пробелами
i = 1          # Ошибка: команда 'i' не найдена
name = "Alex"  # Ошибка
count = 10     # Ошибка
```

### 2. Сравнения в `[ ]` и `[[ ]]` - пробелы ОБЯЗАТЕЛЬНЫ

```bash
# ✅ ПРАВИЛЬНО - с пробелами
if [ "$a" -eq "$b" ]; then
if [[ "$name" == "Alex" ]]; then

# ❌ НЕПРАВИЛЬНО - без пробелов
if ["$a" -eq "$b"]; then      # Ошибка
if [["$name" == "Alex"]]; then # Ошибка
```

### 3. Арифметические операции в `(( ))` - пробелы НЕ ОБЯЗАТЕЛЬНЫ

```bash
# ✅ ОБА варианта работают
((i=1))        # без пробелов
(( i = 1 ))    # с пробелами - тоже работает

((a>b))        # без пробелов
(( a > b ))    # с пробелами - читаемее

((result=a+b)) # без пробелов
(( result = a + b )) # с пробелами
```

## Практические примеры

### Циклы for:

```bash
# ✅ ОБА варианта работают в (( ))
for ((i=1; i<=5; i++)); do
for (( i = 1; i <= 5; i++ )); do
```

### Присваивание в условиях:

```bash
# ✅ ПРАВИЛЬНО
count=0
((count = count + 1))
((count+=1))
count=$((count + 1))

# ❌ НЕПРАВИЛЬНО
count = 0                    # Ошибка!
count = $((count + 1))       # Ошибка!
```

## Почему такие правила?

### Присваивание без пробелов:
```bash
# Bash интерпретирует это как команду 'i' с аргументами '=' и '1'
i = 1

# А это - присваивание переменной
i=1
```

### Сравнения с пробелами:
```bash
# [ - это команда (синоним test), которой нужны аргументы
[ "$a" -eq "$b" ]  # команда [ получает 4 аргумента

# Без пробелов - один аргумент, который непонятно как разбирать
["$a" -eq "$b"]    # ошибка
```

## Рекомендации по стилю

### Для лучшей читаемости:

```bash
# ✅ Читаемо и правильно
i=1
name="Alex"
(( i = 1 ))
(( result = a + b ))
if [ "$count" -eq 10 ]; then
if [[ "$name" == "Alex" ]]; then
```

### Сравнение стилей:

```bash
# Компактный стиль (часто используется)
for((i=0;i<10;i++)); do
    ((result=i*2))
done

# Читаемый стиль (рекомендуется)
for (( i = 0; i < 10; i++ )); do
    (( result = i * 2 ))
done
```

## Итог:

- **Присваивание**: `переменная=значение` (без пробелов)
- **Сравнения в [ ]/[[ ]]**: `[ аргументы ]` (с пробелами)
- **Арифметика в (( ))**: пробелы опциональны, но для читаемости лучше с пробелами

Так что `i=1` без пробелов - это требование синтаксиса, а не опциональный стиль!