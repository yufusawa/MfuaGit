### [Вернуться на Главную](/README.md)

Лекция 4.

Рассмотрим классификации ошибок в C++, актуальные для современных стандартов (C++11/17/20 и выше).

---

### Классификация 1: По времени возникновения (Когда они обнаруживаются?)

Это самая практичная классификация для разработчиков и тестировщиков.

#### 1. Ошибки компиляции (Compile-time Errors)
Обнаруживаются компилятором на этапе сборки. Программа не создается.

*   **Синтаксические ошибки:** Нарушение правил языка.
    ```cpp
    int main() {
        std::cout << "Hello, world!   // Ошибка: незакрытая кавычка
        return 0;
    }
    ```
*   **Ошибки типов (Type Errors):** Несоответствие типов.
    ```cpp
    int x = "hello"; // Ошибка: нельзя преобразовать `const char*` в `int`
    ```
*   **Ошибки линковки (Linkage Errors):** Обнаруживаются linker'ом, когда он не может найти определение для объявленной функции или переменной.
    ```cpp
    // file1.cpp
    void foo(); // объявление

    int main() { foo(); } // ошибка линковки: `foo` не определена

    // file2.cpp
    // Определение foo() отсутствует
    ```

#### 2. Ошибки времени выполнения (Runtime Errors)
Программа компилируется и запускается, но аварийно завершается или ведет себя непредсказуемо во время работы.

*   **Ошибки сегментации (Segmentation Fault):** Попытка доступа к памяти, которая не принадлежит программе (например, разыменование `nullptr`).
    ```cpp
    int* ptr = nullptr;
    *ptr = 5; // Runtime Error: Segmentation Fault
    ```
*   **Исключения (Exceptions):** Программа генерирует исключение, которое не было перехвачено.
    ```cpp
    #include <stdexcept>
    void riskyFunction() { throw std::runtime_error("Something went wrong!"); }
    int main() { riskyFunction(); } // Завершится с необработанным исключением
    ```
*   **Неопределенное поведение (Undefined Behavior, UB):** Самый коварный тип ошибок. Программа может работать, падать или выдавать странные результаты в зависимости от компилятора, оптимизаций и фазы луны.
    ```cpp
    int arr[3] = {1, 2, 3};
    int x = arr[5]; // UB: доступ за границы массива. Может сработать, а может и нет.
    ```

#### 3. Ошибки логики (Logical Errors)
**Самые сложные для обнаружения.** Программа работает, не падает, но выдает неправильный результат.

*   **Ошибки в алгоритме:**
    ```cpp
    // Цель: вычислить сумму чисел от 1 до n
    int sum(int n) {
        int total = 0;
        for (int i = 1; i < n; i++) { // Ошибка: должно быть i <= n
            total += i;
        }
        return total; // Для n=5 вернет 10, а не 15
    }
    ```
*   **Ошибки в условиях:**
    ```cpp
    if (temperature >= 30 || temperature <= 25) { // Логическая ошибка в условии
        std::cout << "Комфортная температура\n"; // Будет выводиться для ЛЮБОЙ температуры
    }
    ```

---

### Классификация 2: По природе ошибки (В чем коренная причина?)

Эта классификация помогает понять суть проблемы.

#### 1. Ошибки, связанные с памятью (Memory-related Errors)
**"Визитная карточка" C++,** источник огромного количества уязвимостей и сбоев.

*   **Утечки памяти (Memory Leaks):** Память выделена (`new`/`malloc`), но не освобождена (`delete`/`free`).
    ```cpp
    void leak() {
        int* ptr = new int[1000];
        // ... использование ptr ...
        // delete[] ptr; // Забыли освободить память
    } // После выхода из функции указатель ptr уничтожается,
      // но выделенная память остается занятой.
    ```
*   **Висячие указатели (Dangling Pointers):** Указатель ссылается на уже освобожденную память.
    ```cpp
    int* createInt() {
        int x = 10;
        return &x; // Возвращаем указатель на локальную переменную
    } // x уничтожается здесь, память становится невалидной

    int main() {
        int* ptr = createInt();
        std::cout << *ptr; // UB: чтение из невалидной памяти
    }
    ```
*   **Двойное удаление (Double Free):** Попытка освободить одну и ту же память дважды.
    ```cpp
    int* ptr = new int;
    delete ptr;
    delete ptr; // UB: двойное удаление
    ```

#### 2. Ошибки, связанные с ресурсами (Resource Management)
Более общая категория, чем память: файлы, сокеты, мьютексы.

*   **Утечка ресурсов (Resource Leak):**
    ```cpp
    std::ofstream file("data.txt");
    file << "important data";
    // file.close(); // Забыли закрыть файл. Деструктор закроет его, но если исключение...
    ```

#### 3. Ошибки, связанные с многопоточностью (Concurrency Errors)
Проявляются только при одновременном выполнении нескольких потоков.

*   **Состояние гонки (Race Condition):** Два или более потока обращаются к общим данным, и хотя бы один из них изменяет их.
    ```cpp
    #include <thread>
    int counter = 0;

    void increment() { for (int i = 0; i < 100000; ++i) ++counter; }

    int main() {
        std::thread t1(increment);
        std::thread t2(increment);
        t1.join(); t2.join();
        // counter будет меньше 200000 из-за неатомарности операции ++
    }
    ```
*   **Взаимная блокировка (Deadlock):** Два или более потока бесконечно ждут друг друга.
    ```cpp
    std::mutex m1, m2;
    // Поток 1: захватывает m1, затем пытается захватить m2
    // Поток 2: захватывает m2, затем пытается захватить m1
    // Результат: вечная блокировка.
    ```

---

### Классификация 3: Специфические ошибки C++ (Связанные с особенностями языка)

#### 1. Ошибки на этапе компиляции (шаблоны)
*   **Подстановка шаблона (Template Instantiation):** Ошибки в шаблонном коде часто выдают километровые сообщения об ошибках.
    ```cpp
    template<typename T>
    T add(T a, T b) { return a + b; }

    struct MyStruct {} s1, s2;
    auto result = add(s1, s2); // Ошибка: оператор `+` не определен для MyStruct
    ```

#### 2. Семантические ошибки ООП (Object-Oriented Programming)
*   **Срезка объекта (Object Slicing):** Потеря информации о производном классе при присваивании объекту базового класса.
    ```cpp
    class Base { public: int a; };
    class Derived : public Base { public: int b; };

    Derived d;
    Base b = d; // Срезка! Поле `b` объекта `d` теряется.
    ```
*   **Нарушение принципа подстановки Лисков (LSP):** Неправильная реализация наследования.

#### 3. Ошибки работы с типами и преобразований
*   **Неявное преобразование типов:**
    ```cpp
    double d = 5.7;
    int i = d; // Неявное преобразование с потерей данных (i = 5)
    ```
*   **`reinterpret_cast` без понимания последствий:**
    ```cpp
    float f = 3.14f;
    int i = reinterpret_cast<int&>(f); // Опасно! Интерпретирует биты float как int.
    ```

---

### Стратегии борьбы с ошибками в C++ (Практические советы)

1.  **Для ошибок компиляции:** Используйте современные IDE с подсветкой синтаксиса и "живой" проверкой кода (Clang-Tidy, Resharper C++).
2.  **Для ошибок времени выполнения и UB:**
    *   **Инструменты:** Санитайзеры (AddressSanitizer, UndefinedBehaviorSanitizer, LeakSanitizer) — ваш лучший друг. Они обнаруживают большинство ошибок памяти и UB на этапе тестирования.
    *   **Идиомы:** Используйте **RAII (Resource Acquisition Is Initialization)** и умные указатели (`std::unique_ptr`, `std::shared_ptr`). Это автоматически решает 95% проблем с памятью и ресурсами.
        ```cpp
        // Больше не нужно вызывать delete вручную!
        auto ptr = std::make_unique<int>(42);
        ```
    *   **Стандарты:** Предпочитайте конструкции из STL и современного C++ (`std::vector` вместо сырых массивов, `std::string` вместо `char*`).
3.  **Для логических ошибок:**
    *   **Покрытие кода (Code Coverage):** Пишите модульные тесты (Google Test, Catch2) и следите, чтобы они покрывали все ветвления кода.
    *   **Статический анализ:** Используйте PVS-Studio, Cppcheck, Clang Static Analyzer для поиска потенциальных ошибок до запуска программы.
4.  **Для ошибок многопоточности:**
    *   **Примитивы высокого уровня:** Используйте `std::async`, `std::future`, высокоуровневые библиотеки вместо ручной работы с мьютексами.
    *   **Инструменты:** ThreadSanitizer (TSan) для обнаружения состояний гонки.

**Вывод:** Понимание классификации ошибок в C++ — это первый и критически важный шаг к написанию стабильного, безопасного и эффективного кода. Современный C++ предоставляет мощные инструменты (умные указатели, санитайзеры, статические анализаторы), чтобы свести риск этих ошибок к минимуму.