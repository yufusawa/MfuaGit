### [Вернуться на Главную](/README.md)

Лекция 5.

---

### Часть 1: Проверка кода (Статический анализ)

Цель — найти ошибки **до запуска** программы.

#### 1.1 Проверка на уровне компилятора

Это первый и обязательный рубеж обороны.

*   **Включите все предупреждения:**
    *   **GCC/Clang:** `-Wall -Wextra -Wpedantic -Werror` (последнее превращает предупреждения в ошибки)
    *   **MSVC:** `/W4 /WX`
*   **Современные стандарты:** Используйте флаги типа `-std=c++17` или `-std=c++20`. Современный стандарт часто означает более строгую проверку типов и лучшую диагностику.
*   **Совет:** Относитесь к предупреждениям компилятора как к ошибкам. Часто они указывают на потенциальные баги или "запашкИ" кода.

#### 1.2 Статический анализ кода

Инструменты, которые анализируют исходный код на предмет шаблонов, ведущих к ошибкам.

*   **Clang-Tidy:** Де-факто стандарт для C++. Проверяет стиль, находить потенциальные баги, предлагает современные идиомы C++ (modernize-* checks).
    ```bash
    clang-tidy myfile.cpp -- -std=c++17 -Imy_include_dir
    ```
    *Пример:* Найдет места, где можно заменить `new`/`delete` на `std::make_unique`.

*   **Cppcheck:** Легковесный, независимый анализатор. Хорош для поиска утечек памяти, выхода за границы массивов, неопределенного поведения.
    ```bash
    cppcheck --enable=all --inconclusive myproject/
    ```

*   **PVS-Studio:** Мощный коммерческий анализатор с очень глубокой проверкой. Имеет бесплатную версию для отдельных проектов.

#### 1.3 Динамический анализ (Санитайзеры)

Инструменты, которые добавляют в вашу программу дополнительную проверяющую логику и требуют **запуска** программы (хотя бы тестов). Это "золотой стандарт" для поиска сложных runtime-ошибок.

*   **AddressSanitizer (ASan):** Обнаруживает ошибки памяти:
    *   Выход за границы массива (heap, stack, global buffer overflow)
    *   Использование памяти после освобождения (use-after-free)
    *   Использование памяти после выхода из области видимости (stack-use-after-return)
    *   Двойное освобождение (double-free)

    **Как использовать (GCC/Clang):**
    ```bash
    g++ -fsanitize=address -g myprogram.cpp -o myprogram
    ./myprogram # При ошибке ASan выведет детальный отчет
    ```

*   **UndefinedBehaviorSanitizer (UBSan):** Обнаруживает неопределенное поведение:
    *   Целочисленное переполнение
    *   Разыменование `nullptr`
    *   Использование неинициализированных переменных

    **Как использовать:**
    ```bash
    g++ -fsanitize=undefined -g myprogram.cpp -o myprogram
    ```

*   **ThreadSanitizer (TSan):** Обнаруживает состояния гонки (data races) в многопоточном коде.
    ```bash
    g++ -fsanitize=thread -g myprogram.cpp -o myprogram
    ```

**Ключевой момент:** Все санитайзеры требуют флага `-g` для привязки ошибок к конкретным строкам кода.

---

### Часть 2: Отладка (Динамический анализ)

Цель — найти причину уже проявившейся ошибки.

#### 2.1 Отладочный вывод ("Логирование")

Самый простой, но часто неэффективный метод.

*   **Плюсы:** Быстро, не требует специальных инструментов.
*   **Минусы:** Загромождает код, требует перекомпиляции, легко пропустить важное место.
    ```cpp
    std::cout << "[DEBUG] Значение x: " << x << ", указатель ptr: " << ptr << std::endl;
    ```

#### 2.2 Использование Отладчика (Debugger)

**Это основной и самый мощный инструмент отладки.**

*   **Популярные отладчики:**
    *   **GDB (GNU Debugger):** Стандарт для Linux/macOS.
    *   **LLDB:** Часть проекта LLVM, современная альтернатива GDB.
    *   **Отладчик в Visual Studio:** Интегрирован в IDE, очень удобен.

*   **Базовые команды GDB/LLDB:**
    ```bash
    gdb ./myprogram
    ```
    *   `run` или `r` — запустить программу.
    *   `break <функция/строка>` или `b` — установить точку останова.
        *   `b main`, `b myfile.cpp:25`
    *   `next` или `n` — выполнить следующую строку (не заходя в функции).
    *   `step` или `s` — выполнить следующую строку (заходя в функции).
    *   `print <выражение>` или `p` — напечатать значение переменной или выражения.
        *   `p variable`, `p *pointer`, `p function_call()`
    *   `backtrace` или `bt` — показать стек вызовов (кто кого вызывал).
    *   `continue` или `c` — продолжить выполнение до следующей точки останова.
    *   `watch <переменная>` — остановиться, когда значение переменной изменится.

#### 2.3 Интегрированная среда разработки (IDE)

Современные IDE (Visual Studio, CLion, Qt Creator) предоставляют графическую оболочку над отладчиком.

*   **Визуальное выполнение:** Видите, как "прыгает" стрелочка по коду.
*   **Просмотр переменных:** Окно, где в реальном времени отображаются все локальные переменные.
*   **Мышиный ховер:** Наведите курсор на переменную в коде — увидите её значение.
*   **Визуальное представление сложных структур:** Деревья, списки, карты (map) отображаются в удобном для просмотра виде.

---

### Практический пример: Пошаговая отладка сегфолта

Допустим, у нас есть программа, которая падает с Segmentation Fault.

```cpp
// buggy_code.cpp
#include <iostream>

int main() {
    int* ptr = nullptr;
    std::cout << "Before crash\n";
    *ptr = 42; // Здесь происходит SegFault!
    std::cout << "After crash\n";
    return 0;
}
```

**Шаги отладки:**

1.  **Компиляция с отладочной информацией:**
    ```bash
    g++ -g buggy_code.cpp -o buggy_code
    ```

2.  **Запуск в GDB:**
    ```bash
    gdb ./buggy_code
    ```

3.  **Запуск программы внутри GDB:**
    ```bash
    (gdb) run
    ```
    Программа выполнится и упадет. GDB покажет:
    ```
    Program received signal SIGSEGV, Segmentation fault.
    0x000000000040155b in main () at buggy_code.cpp:7
    7           *ptr = 42; // Здесь происходит SegFault!
    ```

4.  **Анализ состояния:**
    *   GDB автоматически остановился на строке с ошибкой.
    *   Смотрим стек вызовов:
        ```bash
        (gdb) backtrace
        #0  0x000000000040155b in main () at buggy_code.cpp:7
        ```
    *   Смотрим значение указателя `ptr`:
        ```bash
        (gdb) print ptr
        $1 = (int *) 0x0
        ```
        Мы видим, что `ptr` равен `0x0` (то есть `nullptr`). Причина ошибки найдена!

---

### Проактивные методы (Как меньше дебажить)

1.  **Пишите модульные тесты (Google Test, Catch2):** Чем раньше найдете баг, тем дешевле его исправить.
2.  **Используйте систему сборки (CMake):** Настройте цели для статического анализа (`make clang-tidy`) и запуска с санитайзерами (`make asan_test`).
3.  **Логируйте осмысленно:** Используйте библиотеки вроде spdlog для структурированного логирования с разными уровнями (info, debug, error).
4.  **Придерживайтесь RAII и умных указателей:** `std::unique_ptr` и `std::shared_ptr` сведут к минимуму ошибки управления памятью.
5.  **Упрощайте код:** Сложный код — рассадник багов. Разбивайте функции, используйте понятные именования.

### Итог

Проверка и отладка в C++ — это не один инструмент, а **процесс и набор практик**:

1.  **Компилятор с максимальным уровнем предупреждений** — первая защита.
2.  **Статические анализаторы (Clang-Tidy)** — поиск паттернов ошибок.
3.  **Санитайзеры (ASan, UBSan)** — обнаружение сложных runtime-ошибок в тестах.
4.  **Отладчик (GDB/IDE)** — исследование и исправление конкретных сбоев.
5.  **Хорошие практики (тесты, RAII, простой код)** — предотвращение ошибок на этапе разработки.

Освоив этот стек, вы превратитесь из "охотника за багами" в инженера, который создает стабильный и надежный код с самого начала.