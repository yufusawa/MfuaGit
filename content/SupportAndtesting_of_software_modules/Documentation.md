### [Вернуться на Главную](/README.md)

## Поддержка и тестирование программных модулей

Лекция 1.

Тестирование как часть процесса верификации программного обеспечения
Требуемые условия завершения
Тестирование — это одна из техник контроля качества, которая включает активности по планированию работ, проектированию тестов, выполнению тестирования и анализу полученных результатов.

Тестировщик — специалист, который занимается тестированием. В его обязанности входит поиск возможных ошибок и сбоев в функционале тестирования объекта (например, приложения)

Тестировщик моделирует ситуации, вероятные при использовании тестируемого объекта, чтобы потом разработчики могли устранить обнаруженные неполадки.

Инженер-тестировщик — это человек, решающий проблемы технического характера, связанные с разработкой ПО. Он и пользователь, и эксперт в одном лице: он должен быть способен как воспроизвести действия пользователя, так и проанализировать с точки зрения инженера поведение программы, входные параметры и результаты на выходе.

Очевидно, что если продукт не тестировать, в нем будут ошибки. Что будет, если сэкономить на тестировании ?

Пользователи будут недовольны.
Если сервис не решает задачи пользователей, они будут злится.
Сервис потеряет аудиторию.
Пользователь уйдет к конкурентам, если приложение работает плохо.
Бизнес потеряет репутацию и деньги.
Никто не захочет инвестировать в плохой бизнес.
Интересный факт

Наглядный пример, когда дефект привел к потере 125 млн долларов: в 1999 году спутник «Mars Climate Orbiter» распался в атмосфере. Оказалось, что разработчики забыли перевести английские единицы измерения в метрические.

Основные «эпохи тестирования»

В 50-60-х годах  процесс тестирования был предельно формализован, отделен от процесса непосредственной разработки ПО и «математизирован». Фактически тестирование представляло собой скорее отладку программ (debugging). Существовала концепция «исчерпывающего тестирования (exhaustive testing)» — проверки всех возможных путей выполнения кода со всеми возможными входными данными. Очень скоро было выяснено, что исчерпывающее тестирование невозможно, т.к. количество возможных путей и входных данных очень велико, а также при таком подходе сложно найти проблемы в документации.

В 70-х годах фактически родились две фундаментальные идеи тестирования: тестирование сначала рассматривалось как процесс доказательства работоспособности программы в некоторых заданных условиях (positive testing), а затем — строго наоборот: как процесс доказательства неработоспособности программы в некоторых заданных условиях (negative testing). Это внутреннее противоречие не только не исчезло со временем, но и в наши дни многими авторами совершенно справедливо отмечается как две взаимодополняющие цели тестирования.
• Тестирование позволяет удостоверится, что программа соответствует требованиям;
• Тестирование позволяет определить условия, при которых программа ведет себя некорректно.

В 80-х годах произошло ключевое изменение места тестирования в разработке ПО: вместо одной из финальных стадий создания проекта. Тестирование стало применяться на протяжении всего цикла разработки, что позволило в очень многих случаях не только быстро обнаруживать и устранять проблемы, но даже предсказывать и предотвращать их появление. В этот же период времени отмечено бурное развитие и формализация методологий тестирования и появление первых элементарных попыток автоматизировать тестирование.

В 90-х годах произошел переход от тестирования как такового к более всеобъемлющему процессу, который называется «обеспечение качества (quality assurance)», охватывает весь цикл разработки ПО и затрагивает процессы планирования, проектирования, создания и выполнения тест-кейсов и тестовых окружений.
Тестирование вышло на качественно новый уровень, который естественным образом привел к дальнейшему развитию методологий, появлению достаточно мощных инструментов управления процессом тестирования, уже вполне похожих на своих нынешних потомков.

В нулевые годы развитие тестирования продолжалось в контексте поиска все новых и новых путей, методологий, техник и подходов к обеспечению качества.
Серьезное влияние на понимание тестирования оказало появление гибких методологий разработки и таких подходов, как «разработка под управлением тестированием (test-driven development, TDD)».
Автоматизация тестирования уже воспринималась как обычная неотъемлемая часть большинства проектов, а также стали популярны идеи о том, что во главу процесса тестирования следует ставить не соответствие программным требованиям, а её способность предоставить конечному пользователю возможность эффективно решать свои задачи.

О современном этапе развития тестирования стоит отметить основные характеристики: гибкие методологии и гибкое тестирование, глубокая интеграция с процессом разработки, широкое использование автоматизации, колоссальный набор технологий и инструментальных средств, кросс функциональность команды (когда тестировщик и программист во многом могут выполнять работу друг друга).

Цель тестирования

Цель тестирования — это проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.
Обнаружение и исправление ошибок составляет 40-80% общей стоимости разработки ПО. Такие большие средства тратятся на поиск и устранение ошибок, которые есть в любом продукте
Цель тестировщика — найти максимально возможное количество ошибок, и чем серьезнее обнаруженные проблемы — тем лучше. В итоге, максимум ошибок исправляется, и качество ПО повышается.

Баг

9 сентября 1945 года Грейс Мюррей Хоппер проверяла первый компьютер Mark на неисправности. Оказалось, что внутри застрял мотылёк.
В этот момент в комнату вошел сослуживец и поинтересовался, чем занимается Грей.
Она ответила, что очищает компьютер от насекомых (англ. bug — насекомое, debugging — избавление от насекомых).



Насекомое было извлечено и вклеено в дневник с сопроводительной подписью «Первый реальный случай обнаружения бага». От этого случая и пошло слово bug, а этот день стал днём бага (и заодно днём тестировщика).



Баг — это несоответствие ожидаемого и фактического результатов проверок сервиса.
Ожидаемый результат (ОР) — то, как сервис должен работать согласно требованиям.
Фактический результат (ФР) — то как сервис работает на самом деле

Дальше материал в данном уроке можете не конспектировать, рекомендуется к прочтению

Крупные баги в истории

Y2K — проблемы тысячелетия

Проблема Y2K ещё известна как «проблема 2000 года». Разработчики ПО в XX веке часто использовали для обозначения года в датах две последние цифры вместо привычных четырёх. Например, 7 апреля 1994 года представлялось как «07.04.94».

Так информация хранилась более эффективно — ведь в то время каждый байт был на счету, а базы данных могли хранить тысячи дат. В таком случае сокращение было разумным решением. Или нет?

1 января 2000 по всему миру начали происходить локальные конфликты и сбои в системах. В некоторых городах даже начало пропадать электричество, отопление, часть вычислительных центров просто зависала. Всё это произошло из-за сокращения формата года. После 1999 года наступил 2000, но для машин этот год воспринимался как 1900 (у некоторых даже как 19100). Такая ошибка послужила причиной зависаний во многих системах.



Однако никакой масштабной мировой катастрофы не произошло благодаря тому, что разработчики начали задумываться об этой проблеме заранее. По некоторым оценкам, на подготовку к 2000 году общие мировые затраты составили 300 млрд. долларов.

Торговля — трудное ремесло

В самом начале на Amazon можно было заказать отрицательное количество товара. В таком случае при покупке деньги не списывались, а зачислялись на карту клиента. Такая глупая ошибка случилась из-за того, что разработчик магазина Джефф Безос старался как можно чаще выпускать обновления для своего сервиса и у него не хватало времени на его отладку.



Как отмечает сам разработчик, это одна из его любимых ошибок: «Мы переводили покупателям деньги и, соответственно, ждали, когда этот товар доставят нам».

Примитивные баги в программах случались и в других интернет-магазинах. Иногда можно было выставить в поле «Количество товара» значение 0,01 и тем самым получить скидку на товар в 99%. А в некоторых сервисах персональные данные хранились в файлах cookie. Можно было изменять ID покупателя и совершать покупки от другого лица.

Падение телефонной линии A&T

Один из 114 коммутаторов AT&T был механически повреждён. Он отправил сообщение о поломке другим АТС, а те, в свою очередь, соседним. Запустилась цепная реакция, которая положила телефонную сеть на 9 часов, из-за чего 60 тыс. человек остались без связи.

Причина была в недавнем обновлении ПО для АТС. Теперь, если ломался один из коммутаторов, он посылал об этом сообщения соседним коммутаторам, чтобы те перехватывали его трафик. Тогда другие коммутаторы должны были перезагружаться в новый режим работы и периодически проверять, не заработал ли первый.

Однако из-за бага в коде неисправный коммутатор высылал по два сообщения. Второе сообщение достигало других коммутаторов прямо во время их перезагрузки. Из-за этого они начинали думать, что сами неисправны и рассылали сообщение дальше по цепи. Таким образом, словно домино, упала целая сеть. Общие потери компании составили примерно 60 млн. долларов.

Взрыв ракеты Ariane 5 из-за переполнения переменной

Авария ракеты-носителя «Ариан-5» произошла 4 июня 1996 г. Ракета разрушилась на 40-й секунде полёта из-за неверной работы бортового ПО. Этот баг в системе — самый дорогостоящий в нашем топе багов и вообще в мире — его ущерб оценивается от 360 до 500 млн. долларов. В результате аварии были также потеряны 4 спутника Cluster.

Во время разработки бортового программного обеспечения некоторые фрагменты кода были взяты из ПО предыдущей удачной Ariane 4. Однако софт так и не протестировали в новом окружении. После старта ракеты её модуль попытался просчитать определённое значение, исходя из горизонтальной скорости ракеты. Так как эта скорость у Ariane 5 была намного выше, чем у предыдущей версии, это вызвало переполнение переменной, что, в свою очередь, повлекло ошибки. На борту была запасная система управления, но т. к. в ней было идентичное ПО, ошибка повторилась.

Работы над строительством ракеты велись на протяжении 10 лет, а на разработку было потрачено 7 млрд. долларов.

Советский аппарат «Луноход-2» (запущен 8 января 1973 года на борту станции «Луна-21») не смог проработать на Луне долго. Миссия завершилась 10 мая 1973 года из-за черезмерной нагрузки на механизмы и аппаратуру аппарата.

Причины:
1. Повреждение системы навигации при посадке. Экипажу с Земли приходилось ориентироваться по окружающей обстановке и Солнцу. Как следствие, Луноход 2 прилунился на дно лунного кратера (Посадка — 15 января 1973 года в кратере Лемонье на восточной окраине Моря Ясности.)

1. Забуксование аппарата в лунном грунте. В один из дней «Луноход-2» снова заехал внутрь свежего лунного кратера и там забуксовал из-за рыхлого грунта.

1. Попадание лунной пыли на поверхность аппарата во время манёвра. Это привело к перегреву аппаратуры и выходу её из сроя

За время работы (с 16 января по 10 мая 1973 года) аппарат преодолел почти 40 километров. Передал на Землю 86 фото-телепанорам и более 80 тысяч снимков поверхности Луны. Получил стереоскопические изображения особенностей лунного рельефа, которые позволили изучить его строение.

Итог:

После потери «Лунохода-2» советская программа по исследованию Луны фактически замерла. Были планы на новые миссии, но их не запустили.



> Средства разработки технической документации — это ключевой аспект зрелой процессов разработки ПО. Правильные инструменты не просто создают документы, а становятся частью жизненного цикла модуля, напрямую влияя на качество тестирования и легкость поддержки.

Давайте разберем эту тему подробно, разделив инструменты по их основным целям и связав их с процессами тестирования и поддержки.

### Ключевые принципы (Почему это важно?)

Перед обзором инструментов сформулируем цели, которым они служат:

1.  **Единственный источник истины:** Документация должна жить в одном месте, а не в разрозненных Word-файлах и Wiki-страницах.
2.  **Живая документация:** Документация должна автоматически обновляться при изменении кода (особенно API), а не отставать от него.
3.  **Связь между кодом, тестами и документацией:** Изменения в коде должны триггерить пересборку документации и пересмотр тестов.
4.  **Автоматизация:** Процесс генерации документации должен быть частью CI/CD-пайплайна.

---

### Категории средств разработки технической документации

#### 1. Инструменты для документирования архитектуры и дизайна модулей (High-Level Design - HLD / Low-Level Design - LLD)

Эти документы описывают, *что* делает модуль, *как* он устроен внутри и как взаимодействует с другими модулями.

*   **Классические инструменты:**
    *   **Draw.io / Diagrams.net:** Бесплатный, мощный инструмент для создания диаграмм (UML, последовательностей, компонентов). Диаграммы можно хранить в репозитории вместе с кодом.
    *   **Lucidchart:** Аналог Draw.io с расширенными возможностями для командной работы.
    *   **PlantUML:** **Ключевой инструмент для автоматизации.** Позволяет описывать диаграммы в виде текстового кода. Это позволяет:
        *   Хранить диаграммы в системе контроля версий (Git).
        *   Включать генерацию диаграмм в процесс сборки.
        *   Легко находить различия между версиями.

    **Связь с тестированием и поддержкой:**
    *   **Тестирование:** Диаграммы последовательностей и состояний помогают тестировщикам понять сценарии использования и построить тест-кейсы. Архитектурные диаграммы помогают определить границы модуля для модульного и интеграционного тестирования.
    *   **Поддержка:** При поступлении бага инженер поддержки может быстро понять контекст модуля, не погружаясь в код.

#### 2. Инструменты для документирования API (Application Programming Interface)

Это критически важная категория для модулей, предоставляющих API.

*   **Инструменты, основанные на спецификациях:**
    *   **OpenAPI / Swagger:** Де-факто стандарт для REST API. Вы описываете API в YAML или JSON-файле, а инструменты генерируют:
        *   Интерактивную документацию (Swagger UI).
        *   Клиентские и серверные заглушки (SDK).
        *   Коллекции для тестирования (Postman).
    *   **AsyncAPI:** Аналог OpenAPI для асинхронных API (например, на основе message brokers like Kafka, RabbitMQ).
    *   **GraphQL Schema:** Схема GraphQL сама по себе является строго типизированной документацией.

*   **Генераторы документации:**
    *   **Slate, ReDoc, Stoplight:** Генераторы, которые создают красивые и удобочитаемые статические сайты из OpenAPI-спецификаций.

    **Связь с тестированием и поддержкой:**
    *   **Тестирование:** OpenAPI-спецификация может использоваться для **контрактного тестирования** (например, с помощью Schemathesis или Dredd). Тесты автоматически проверяют, что реализация API соответствует документации. Также легко генерируются моки-серверы.
    *   **Поддержка:** Интерактивная документация позволяет инженерам поддержки самостоятельно проверять, как должен работать API, при общении с клиентами.

#### 3. Инструменты для документирования кода (In-line Documentation)

Документация, которая живет прямо в исходном коде.

*   **Системы генерации документации из комментариев:**
    *   **Javadoc (Java), Doxygen (C++, C, др.), Sphinx (Python) с расширением autodoc, DocFX (.NET):** Эти инструменты анализируют специальные комментарии в коде и генерируют полноценные сайты с документацией по классам, методам, параметрам.

    **Связь с тестированием и поддержкой:**
    *   **Тестирование:** Разработчики модулей и тестировщики четко видят предназначение каждого метода, его ожидаемые входные данные и возвращаемое значение. Это основа для модульных тестов.
    *   **Поддержка:** Инженер, разбирающийся в баге, быстрее находит нужный метод и понимает его логику.

#### 4. Универсальные платформы для ведения документации (Documentation-as-Code)

Подход, при котором документация пишется в виде текстовых файлов (Markdown, AsciiDoc) и хранится вместе с кодом в Git.

*   **Инструменты:**
    *   **MkDocs:** Простой генератор статических сайтов на Python. Легко интегрируется с CI/CD. Плагин `mkdocs-material` предоставляет современный дизайн.
    *   **Sphinx:** Изначально для Python, но стал универсальным. Мощный, поддерживает сложные структуры.
    *   **GitBook:** Коммерческий/условно-бесплатный хостинг для документации с удобным редактором.
    *   **Docusaurus:** Фреймворк от Meta (Facebook) для создания документационных сайтов, идеально подходит для проектов с открытым исходным кодом.

    **Связь с тестированием и поддержкой:**
    *   **Тестирование:** В такую документацию можно включать **фрагменты кода с тестами**. Можно настроить автоматическую проверку, что эти фрагменты компилируются.
    *   **Поддержка:** Появляется единое, всегда актуальное место, где собрана вся информация о модуле: от общего описания до руководства по устранению неполадок (Troubleshooting). Процесс внесения правок в документацию такой же, как и в код — через Merge/Pull Request.

#### 5. Инструменты для управления тестовой документацией

Хотя тест-кейсы часто ведутся в специализированных системах, их тоже можно рассматривать как часть технической документации модуля.

*   **Инструменты:**
    *   **Test Management Systems (TMS):** Xray, Zephyr Scale, TestRail. Позволяют формализовать тест-кейсы, привязывать их к требованиям/функциям модуля.
    *   **Подход "Тесты как код":** Тесты пишутся в коде (например, JUnit для Java, pytest для Python). А их описание (docstrings) служит документацией. Это обеспечивает самую тесную связь.

---

### Пример рабочего процесса (Как это все работает вместе)

Рассмотрим жизненный цикл нового функционала в модуле "Оплата":

1.  **Проектирование:** Разработчик создает файл `payment_sequence.puml` (PlantUML) и `payment_api.yaml` (OpenAPI), описывающий новый метод API. Файлы коммитятся в Git.
2.  **Реализация:** В код метода добавляются комментарии в формате Javadoc/Docstring.
3.  **Документирование:** В папке `docs/` лежат Markdown-файлы с общим описанием модуля. В одном из них есть ссылка на генерируемую диаграмму и API-спецификацию.
4.  **CI/CD Pipeline (Сборка):**
    *   `git push` в репозиторий.
    *   CI-сервер (например, GitHub Actions, GitLab CI) запускает пайплайн:
        *   **Сборка и тестирование:** Выполняются модульные и интеграционные тесты. Контрактные тесты проверяют API по `payment_api.yaml`.
        *   **Генерация документации:** Запускаются скрипты, которые:
            *   Генерируют PNG-изображения из `*.puml` файлов.
            *   Генерируют красивый HTML-сайт из OpenAPI-спецификации.
            *   Запускают Sphinx/DocFX для генерации документации по коду.
            *   Собирают весь контент (Markdown-файлы, сгенерированные диаграммы и API-доку) в статический сайт с помощью MkDocs.
        *   **Деплой документации:** Сгенерированный сайт автоматически публикуется на хостинге (например, GitHub Pages, GitLab Pages, внутренний сервер).
5.  **Поддержка:** Инженер получает сообщение об ошибке в методе оплаты. Он заходит на актуальный документационный сайт, смотрит на диаграмму последовательностей, проверяет ожидаемые коды ошибок в интерактивной документации API и быстро локализует проблему.

### Итог: Критерии выбора инструментов

Выбирая средства, ориентируйтесь на следующие критерии:

1.  **Интеграция с вашим стэком технологий:** .NET-проекту логично использовать DocFX, Python-проекту — Sphinx.
2.  **Поддержка подхода "Documentation-as-Code":** Предпочтение инструментам, которые работают с текстовыми файлами и интегрируются с Git.
3.  **Возможности автоматизации:** Насколько легко встроить генерацию документации в CI/CD.
4.  **Экосистема:** Наличие плагинов и расширений (например, для генерации диаграмм внутри Markdown).

Правильно выстроенный процесс и подобранные инструменты превращают документацию из обузы в актив, который ускоряет разработку, повышает качество тестирования и радикально упрощает поддержку программных модулей.